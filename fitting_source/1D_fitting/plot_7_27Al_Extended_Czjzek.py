#!/usr/bin/env python
"""
Fitting a Czjzek Model
^^^^^^^^^^^^^^^^^^^^^^
"""
# %%
# In this example, we display the capability of mrsimulator to fit a lineshape from a
# Czjzek distribution of quadrupolar tensors to an experimental $^{27}\text{Al}$ MAS
# spectrum of a phospho-aluminosilicate glass. Setting up a least-squares minimization
# for a  Czjzek distribution is slightly different than that of a crystalline
# solid. There are 4 major steps involved in the process:
#
# 1. Importing the experimental dataset,
# 2. Generating a pre-computed line shape kernel for the experiment,
# 3. Creating parameters for the Czjzek model from an initial guess,
# 4. Minimizing and visualizing.
#
# Below, we first import the requisite libraries, functions, and classes.
import numpy as np
import csdmpy as cp
import matplotlib.pyplot as plt
import mrsimulator.signal_processor as sp
from mrsimulator.simulator import Simulator
import mrsimulator.utils.spectral_fitting as sf
from lmfit import Minimizer

from mrsimulator.method.lib import BlochDecayCTSpectrum
from mrsimulator.utils import get_spectral_dimensions

from mrsimulator.models.czjzek import CzjzekDistribution
from mrsimulator.models.utils import generate_lineshape_kernel

# sphinx_gallery_thumbnail_number = 3

# %%
# Import the experimental dataset
# -------------------------------
#
# Below we import and visualize the experimental dataset.
host = "http://ssnmr.org/sites/default/files/mrsimulator/"
filename = "20K_20Al_10P_50Si_HahnEcho_27Al.csdf"
exp_data = cp.load(host + filename).real

exp_data.x[0].to("ppm", "nmr_frequency_ratio")
exp_data /= exp_data.max()

plt.figure(figsize=(4, 3))
ax = plt.subplot(projection="csdm")
ax.plot(exp_data)
plt.tight_layout()
plt.show()

# %%
# Generating a line shape kernel
# ------------------------------
#
# A spectrum arising from a Czjzek distribution can be modeled by drawing a
# random set of tensors, binning those tensors into a distribution on some grid of
# tensors parameters, then simulating the spectra of spin systems whose abundances
# correspond to the amplitude of that distribution.
#
# For least-squares fitting, however, simulating the spectra of many spin systems during
# each minimization step would be computationally costly, especially since a
# least-squares minimization could take hundreds of steps to complete.
# A more efficient way would be to define a grid for the tensor parameters, simulate a
# spectrum for each point on the grid before minimization, and only update the
# probability distribution on that grid during each minimization step.
#
# Below, we create a `Method` object for simulating the spectra of the given experiment,
# define a polar grid for generating the line shape kernel, and finally call the kernel
# generation method -- `generate_lineshape_kernel`.
# The grid we defined is in polar coordinates, so we pass `polar=True` to the kernel
# generation method; if the grid were defined for the Haeberlen components of the
# tensor, then pass `polar=False`.
# We are also interested in the distribution of the EFG (quadrupolar) tensor, hence
# `tensor_type="quadrupolar"`, but a symmetric shielding lineshape kernel can also be
# generated by passing `tensor_type="shielding"`.
# Create a Method object to simulate the spectrum
spectral_dimensions = get_spectral_dimensions(exp_data)
method = BlochDecayCTSpectrum(
    channels=["27Al"],
    rotor_frequency=14.2e3,
    spectral_dimensions=spectral_dimensions,
    experiment=exp_data,
)

# Define a polar grid for the lineshape kernel
x = np.linspace(0, 2e7, num=36)
y = np.linspace(0, 2e7, num=36)
pos = (x, y)

# Call the kernel generation function with the correct arguments
kernel = generate_lineshape_kernel(
    pos=pos, method=method, polar=True, tensor_type="quadrupolar"
)

print("Desired Kernel shape: ", (x.size * y.size, spectral_dimensions[0]["count"]))
print("Actual Kernel shape:  ", kernel.shape)

# %%
# Create a Parameters object
# --------------------------
# Next, we create an instance of the `ExtCzjzekDistribution` class with initial guess
# values along with a `SignalProcessor` object. A set of minimization parameters are
# then created from this initial guess.
#
# The initial guess and residual spectrum is also plotted to judge the quality of the
# initial guess.
#
# Note that the variable `addtl_sf_kwargs` holds some additional keyword arguments that
# many of the spectral fitting function takes in. This dictionary needs to be updated to
# reflect any changes made in the minimization.

# Create initial guess CzjzekDistribution
cz_model = CzjzekDistribution(
    mean_isotropic_chemical_shift=60.0,  # in ppm
    sigma=1.4e6,
    polar=True,
    cache=True,
)
all_models = [cz_model]

processor = sp.SignalProcessor(
    operations=[
        sp.IFFT(),
        sp.apodization.Gaussian(FWHM="600 Hz"),
        sp.FFT(),
        sp.Scale(factor=30),
    ]
)

sim = Simulator(spin_system_models=all_models, methods=[method])
sim.config.number_of_sidebands = 8

# Make the Parameters object
params = sf.make_LMFIT_distribution_params(
    distribution_models=all_models,
    processor=processor,
)

# Additional keyword arguments passed to best-fit and residual functions.
addtl_sf_kwargs = dict(
    pos=pos,
    kernel=kernel,
    sim=sim,
    processor=processor,
)

# Make a guess and residuals spectrum from the initial guess
guess = sf.bestfit_dist(params=params, **addtl_sf_kwargs)
residuals = sf.residuals_dist(params=params, **addtl_sf_kwargs)

plt.figure(figsize=(4, 3))
ax = plt.subplot(projection="csdm")
ax.plot(exp_data, "k", alpha=0.5, label="Experiment")
ax.plot(guess, "r", alpha=0.3, label="Guess")
ax.plot(residuals, "b", alpha=0.3, label="Residuals")
plt.legend()
plt.grid()
plt.title("Initial Guess")
plt.tight_layout()
plt.show()

# Print the Parameters object
params

# %%
# Create and run a minimization
# -----------------------------
# Finally, a `Minimizer` object is created and a minimization run using least-squares.
# The same arguments defined in the `addtl_sf_kwargs` variable are also passed to the
# minimizer.
scipy_minimization_kwargs = dict(
    diff_step=1e-3,  # Increase step size
    gtol=1e-15,  # Increase global convergence requirement (default 1e-8)
    xtol=1e-15,  # Increase variable convergence requirement (default 1e-8)
    verbose=2,  # Print minimization info during each step
    loss="soft_l1",
)

minner = Minimizer(
    sf.LMFIT_min_function_dist,
    params,
    fcn_kws=addtl_sf_kwargs,
    **scipy_minimization_kwargs,
)
result = minner.minimize(method="least_squares")
result

# %%
# Plot the best-fit spectrum
# --------------------------
bestfit = sf.bestfit_dist(params=result.params, **addtl_sf_kwargs)
residuals = sf.residuals_dist(params=result.params, **addtl_sf_kwargs)

plt.figure(figsize=(4, 3))
ax = plt.subplot(projection="csdm")
ax.plot(exp_data, "k", alpha=0.5, label="Experiment")
ax.plot(bestfit, "r", alpha=0.3, label="Guess")
ax.plot(residuals, "b", alpha=0.3, label="Residuals")
plt.legend()
plt.grid()
plt.title("Best Fit")
plt.tight_layout()
plt.show()

# %%
# Plot the best-fit distribution
# ------------------------------
#
for i, model in enumerate(all_models):
    model.update_lmfit_params(result.params, i)

xx, yy, amp = cz_model.pdf(pos=pos)

plt.figure(figsize=(4, 3))
plt.contourf(xx / 1e6, yy / 1e6, amp)
plt.xlabel("x / MHz ")
plt.ylabel("y / MHz")
plt.tight_layout()
plt.show()
