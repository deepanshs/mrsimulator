#!/usr/bin/env python
"""
Fitting an Extended Czjzek Model
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"""
# %%
# In this example, we display the capability of mrsimulator to fit an Extended Czjzek
# distribution of quadrupolar tensors to an experimental $^{27}\text{Al}$ MAS spectrum
# of a phospho-aluminosilicate glass. Setting up a least-squares minimization for an
# Extended Czjzek distribution is slightly more complicated than that of a crystalline
# solid. There are 4 major steps involved in the process:
#
# 1. Importing the experimental dataset
# 2. Generating a pre-computed linshape kernel for the experiment
# 3. Creating parameters for the Extended Czjzek model from an initial guess
# 4. Minimizing and visualizing.
#
# Below, we first import the requisite libraries, functions, and classes.
import numpy as np
import csdmpy as cp
import matplotlib.pyplot as plt
import mrsimulator.signal_processor as sp
import mrsimulator.utils.spectral_fitting as sf
from lmfit import Minimizer

from mrsimulator.method.lib import BlochDecayCTSpectrum
from mrsimulator.utils import get_spectral_dimensions

from mrsimulator.models.czjzek import ExtCzjzekDistribution
from mrsimulator.models.utils import generate_lineshape_kernel

# sphinx_gallery_thumbnail_number = 3

# %%
# Import the experimental dataset
# -------------------------------
#
# Below we import and visualize the experimental dataset. Line 3 is used to set the
# maximum intensity of the spectrum to 1, but has no other bering on the minimization.
host = "http://ssnmr.org/sites/default/files/mrsimulator/"
filename = "20K_20Al_10P_50Si_HahnEcho_27Al.csdf"
exp_data = cp.load(host + filename).real

exp_data.x[0].to("ppm", "nmr_frequency_ratio")
exp_data /= exp_data.max()

plt.figure(figsize=(4, 3))
ax = plt.subplot(projection="csdm")
ax.plot(exp_data)
plt.tight_layout()
plt.show()

# %%
# Generating a lineshapke kernel
# ------------------------------
#
# A spectrum arising from an Extended Czjzek distribution can be modeled by drawing a
# random set of tensors, binning those tensors into a distribution on some grid of
# tensors parameters, then simulating the spectra of spin systems whose abundances
# correspond to the amplitude of that distribution.
#
# For least-squares fitting, however, simulating the spectra of many spin systems during
# each minimization step would be computationally costly, especially since a
# least-squares minimization could take hundreds of steps to complete.
# A more efficient way would be to define a grid for the tensor parameters, simulate a
# spectrum for each point on the grid before minimization, and only update the
# probability distribution on that grid during each minimization step.
#
# Below, we create a `Method` object for simulating the spectra of the given experiment,
# define a polar grid for generating the lineshape kernel, and finally call the kernel
# generation method -- `generate_lineshape_kernel`.
# The grid we defined is in polar coordinates, so we pass `polar=True` to the kernel
# generation method; if the grid were defined for the Haeberlen components of the
# tensor, then pass `polar=False`.
# We are also interested in the distribution of the EFG (quadrupolar) tensor, hence
# `tensor_type="quadrupolar"`, but a symmetric shielding lineshape kernel can also be
# generated by passing `tensor_type="shielding"`.
# Create a Method object to simulate the spectrum
spectral_dimensions = get_spectral_dimensions(exp_data)
method = BlochDecayCTSpectrum(
    channels=["27Al"], rotor_frequency=14.2e3, spectral_dimensions=spectral_dimensions
)

# Define a polar grid for the lineshape kernel
x = np.linspace(0, 2e7, num=36)
y = np.linspace(0, 2e7, num=36)
pos = (x, y)

# Call the kernel generation function with the correct arguments
kernel = generate_lineshape_kernel(
    pos=pos, method=method, polar=True, tensor_type="quadrupolar"
)

print("Desired Kernel shape: ", (x.size * y.size, spectral_dimensions[0]["count"]))
print("Actual Kernel shape:  ", kernel.shape)

# %%
# Create a Parameters object
# --------------------------
# Next, we create an instance of the `ExtCzjzekDistribution` class with initial guess
# values along with a `SignalProcessor` object. A set of minimization parameters are
# then created from this initial guess.
#
# The initial guess and residual spectrum is also plotted to judge the quality of the
# initial guess.
#
# Note that the variable `addtl_sf_kwargs` holds some additional keyword arguments that
# many of the spectral fitting function takes in. This dictionary needs to be updated to
# reflect any changes made in the minimization.

# Create initial guess ExtCzjzekDistribution
tensor_guess = {"Cq": 1e6, "eta": 0.3}
ext_cz_model = ExtCzjzekDistribution(
    symmetric_tensor=tensor_guess, eps=6, polar=True, cache=True
)
dist_iso_shift = 60  # in ppm

processor = sp.SignalProcessor(
    operations=[
        sp.IFFT(),
        sp.apodization.Gaussian(FWHM="420 Hz"),
        sp.FFT(),
        sp.Scale(factor=25),
    ]
)

# Make the Parameters object
params = sf.make_LMFIT_params_extended_Czjzek(
    ext_cz_models=[ext_cz_model],
    iso_shifts=[dist_iso_shift],
    processor=processor,
    tensor_type="quadrupolar",
)


# Additional keyword arguments passed to best-fit and residual functions.
addtl_sf_kwargs = dict(
    exp_spectrum=exp_data,
    pos=pos,
    kernel=kernel,
    models=[ext_cz_model],
    larmor_freq_Hz=method.channels[0].larmor_freq(B0=method.magnetic_flux_density),
    processor=processor,
    tensor_type="quadrupolar",
)

# Make a guess and residuals spectrum from the initial guess
guess = sf.bestfit_extended_Czjzek(params=params, **addtl_sf_kwargs)
residuals = sf.residuals_extended_Czjzek(params=params, **addtl_sf_kwargs)

plt.figure(figsize=(5, 4))
ax = plt.subplot(projection="csdm")
ax.plot(exp_data, "k", alpha=0.5, label="Experiment")
ax.plot(guess, "r", alpha=0.3, label="Guess")
ax.plot(residuals, "b", alpha=0.3, label="Residuals")
plt.legend()
plt.grid()
plt.title("Initial Guess")
plt.tight_layout()
plt.show()

# Print the Parameters object
params

# %%
# Create and run a minimization
# -----------------------------
# Finally, a `Minimizer` object is created and a minimization run using least-squares.
# The same arguments defined in the `addtl_sf_kwargs` variable are also passed to the
# minimizer.
scipy_minimization_kwargs = dict(
    diff_step=1e-3,  # Increase step size
    gtol=1e-15,  # Increase global convergence requirement (default 1e-8)
    xtol=1e-15,  # Increase variable convergence requirement (default 1e-8)
    verbose=2,  # Print minimization info during each step
    loss="soft_l1",
)


minner = Minimizer(
    sf.LMFIT_min_function_extended_Czjzek,
    params,
    fcn_kws=addtl_sf_kwargs,
    **scipy_minimization_kwargs,
)
result = minner.minimize(method="least_squares")
result

# %%
# Plot the best-fit spectrum
# --------------------------
bestfit = sf.bestfit_extended_Czjzek(params=result.params, **addtl_sf_kwargs)
residuals = sf.residuals_extended_Czjzek(params=result.params, **addtl_sf_kwargs)

plt.figure(figsize=(5, 4))
ax = plt.subplot(projection="csdm")
ax.plot(exp_data, "k", alpha=0.5, label="Experiment")
ax.plot(bestfit, "r", alpha=0.3, label="Guess")
ax.plot(residuals, "b", alpha=0.3, label="Residuals")
plt.legend()
plt.grid()
plt.title("Best Fit")
plt.tight_layout()
plt.show()

# %%
# Plot the best-fit distribution
# ------------------------------
#
# Note that this cell is hardcoded for a single distribution.
epsilon = result.params["ext_czjzek_0_epsilon"].value
bf_tensor = {"eta": result.params["ext_czjzek_0_eta0"].value}
if addtl_sf_kwargs["tensor_type"] == "shielding":
    bf_tensor["zeta"] = result.params["ext_czjzek_0_zeta0"].value
else:
    bf_tensor["Cq"] = result.params["ext_czjzek_0_Cq0"].value

bestfit_model = ExtCzjzekDistribution(
    symmetric_tensor=bf_tensor, eps=epsilon, polar=True
)

xx, yy, amp = bestfit_model.pdf(pos=pos, size=10000000)

plt.figure(figsize=(5, 5))
plt.contourf(xx / 1e6, yy / 1e6, amp)
plt.xlabel("x / MHz ")
plt.ylabel("y / MHz")
plt.tight_layout()
plt.show()
